# 树状数组 BIT

## 原理
&emsp; 在解题过程中有时候需要维护一个数组的前缀和 $S[i] = \sum_{j=1}^{i}A[j]$，如果改变了任意一个 $A[i]$，则 $S[i], S[i+1], \cdots, S[n]$ 都会变。所以在最坏情况下修改 $A[i]$ 并维护 $S$ 数组的时间复杂度位 $O(n)$。但是在有些情况下 $n$ 很大，程序会运行的很慢，所以我们需要用一个新的数据结构来存储。

&emsp; 树状数组和线段树一样，用来维护序列。和线段树一样，它的时间复杂度也是 $O(\log{n})$，但是树状数组的常数比线段树小，但是他的使用条件会更加苛刻，下面会详细说明。

![树状数组样例](/cpp/practice/2021SummerVacation/August2021/20210809/binaryIndexTreeExample.png)

&emsp; 如上图，不难发现 $e[i] = \sum_{j=i-2^k+1}^{i}a[j]$，其中 $k$ 是 $i$ 的二进制表示中末尾 $0$ 的个数。同时 $k$ 也是这个节点在数中的高度。所以 $BIT$ 的更新和区间求和就可以利用二进制运算快速实现。

----
## 线段树与树状数组

&emsp; 在很多情况下，线段树都可以用树状数组实现。凡是能用树状数组实现的都可以用线段树来实现。**但是当题目不符合 *减法原则* 时，就只能用线段树**。 **例如数列操作中让我们求出一段数字中的最大或者最小数字就只能用线段树了。**

&emsp; 线段树和树状数组都是将我们要维护的序列拆成一个个小的区间，并将这些小区间合并，逐步得出大区间的信息。因此使用这两个算法的前提是：***需要维护的信息必须 "可加" ,并且要满足结合律。***

&emsp; 比如求和，大区间等于左右两个校区间的和；区间最小值，大区间的最小是左右两个小区间的最小的较小值。这两个要求都可以用线段树来实现。而像求区间数这种玩意儿就不行，大区间的众数可能既不等于左区间的众数也不等于右区间的众数。因此求中枢就不能用这两个数据结构来简化运算。

&emsp; 注意***树状数组不是直接求出区间和，而是求出前缀和，并且通过减法来求出答案***，因此使用树状数组的时候不仅要满足 "可加"，还要满足 "可减"。所以说这时用 $BIT$ 来求最大和最小，就只能求出前缀的答案，不能得到区间值。

## 应用
1. 单点修改
2. 区间求和

----

## 实现

&emsp; 由上面我们给出的图片可以看出，树状数组的每个数向上指向的是位置比它高一位且在它右侧最近的数。也就是说 $tree[i+lowbit(i)] += tree[i]$。利用这个性质就可以写出树状数组的 update 函数。


int lowbit(int x){<br>
&emsp; return x & (-x);<br>
}


void update(int i, int x){&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; // arr[i] += x;<br>
&emsp; while(i <= n){<br>
&emsp; &emsp; tree[i] += x;<br>
&emsp; &emsp; i += lowbit(i);<br>
&emsp; }<br>
}

&emsp; 根据同样的原理，我们也可以写出树状数组的 query 函数。

int query(int n){&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; //求 1 ~ n 的和<br>
&emsp; int sum = 0;<br>
&emsp; while(n > 0){<br>
&emsp; &emsp; sum += tree[n];<br>
&emsp; &emsp; n -= lowbit(n);<br>
&emsp; }<br>
&emsp; return sum;<br>
}