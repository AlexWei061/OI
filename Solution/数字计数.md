# 数位 DP
&emsp; 本篇主要内容是一片题解传送门：[luogu P2602 数字计数](https://www.luogu.com.cn/problem/P2602)
## 题目描述
>给定两个正整数 a 和 b，求在 [a,b] 中的所有整数中，每个数码(digit)各出现了多少次。输出包含一行十个整数，分别表示 0∼9 在 [a,b] 中出现了多少次。
>输入输出样例：
>输入：1 99
>输出：9 20 20 20 20 20 20 20 20 20

## 分析
&emsp; 乍一看好像是一道大水题，再一看数据范围，$10^{12}$ .....，好吧这题不水。

&emsp; 但是这道题还是很良心的啊，都把 digit 数码在题目中给你写出来了，这不明摆着就是一道数位 DP 的题吗。那我们就来看看能不能把递推式给整出来。 

&emsp; 总思路：我们把从 a 到 b 的所有数字中的各个数码出现的次数转化成这样：1 ~ b 中的所有数字的各个数码出现的次数减去 1 ~ a - 1 中的所有数字的各个数码出现的次数。所以我们现在考虑怎样求出 1 ~ n 的所有数字的各个数码的出现次数。

&emsp; 首先，我们发现这一道题有一个很烦人的东西，叫做 "前导0"，因为有这个东西，所以我们很难直接写出递推式，只能在考虑了没有它的情况之后再减去考虑它之后的那些多出来的值。给没学过数位 DP 的读者们解释一下，"前导0" 是指我们在枚举数位的时候会碰到枚举出来的数是这样的情况：$\overline{0000abc...}$，这些真正的数字前面的 "0" 们我们就叫它们 "前导0"。

&emsp; 首先考虑没有前导 0 的情况，根据我们的 ~~数学常识~~ 我们可以知道，在 0 ~ 9，0 ~ 99，0 ~ 999 ... 这些区间里面，所有数字的出现次数是相同的。不知道这个 ~~c常识~~ 的读者可以试着自己打打表验证一下。如果我们把这些数字出现的次数算出来的话，我们会发现下面这样的规律：
$$
\begin{aligned}
0 \sim 9 &: 1\\
0 \sim 99 &: 20\\
0 \sim 999 &: 300\\
0 \sim 9999 &: 4000\\
0 \sim 99999 &: 50000\\
\vdots
\end{aligned}
$$

&emsp; 这个规律应该是很明显的了，如果我们把所有的 $i$ 位数（含前导0）中隔个数字出现的总次数记为 $f_i$ 那么我们就有 $f_i = 10 \times f_{i-1} + 10^{i-1}$。（不知道怎么计算每个数字出现的次数的也可以试着打一下表，打表程序放在下面了）

```c
int cnt = 0;
for(int i = 1; i < 10000000; i++){
	int temp = i;
	while(temp){
		int x = temp % 10;
		if(x == 1){                       // 所有数字出现次数一样，所以只用统计 1
			cnt++;
		}
		temp /= 10;
	}
} 
printf("%d\n", cnt);
```

&emsp; 既然我们有了这个规律，很自然的我们根据分治的思想可以想到把数字 a 分成不同的部分，我们考虑这样分（假设 $a = \overline{ABCD}$）：从最高位开始分别处理不同的位数，也就是分别处理：$\overline{A000}$，$\overline{0B00}$， $\overline{00C0}$ 和 $\overline{000D}$。

&emsp; 首先我们来讨论如何处理最高位： $\overline{A000}$。因为我们知道 0 ~ 999 之间的每个数字都出现了 $f_3$ 次，所以我们考虑先把这个 $\overline{A000}$ 看成 $\overline{0000} \sim \overline{1000} \sim \overline{2000} \sim \cdots \sim \overline{A000}$。感性的来讲，是不是所有数字都出现了 $A \times f_3$ 次呢？不是的，因为除了这些数字，还要加上首位出现的次数，也就是比 A 小的每个数要多出现 $10^3$ 次。

&emsp; 这应该比较好理解，如果不理解的话我简单的说一下，我们知道 $0 \sim 999$ 中的所有数字的各个数码出现次数相等且都是 $f_3$ 次。那我们是不是可以把这些书写成这样 $\overline{0000}， \overline{0001}，\overline{0002}， \cdots，\overline{0999}$，再看从 $1000 \sim 1999$ 的这些数字，如果忽略最高位 1，那么是不是他们就和 $0 \sim 999$ 一模一样，所以从 $1000 \sim 1999$ 中，所有数字都要出现 $f_3$ 次，且首位 1 会多出现 $10^3$ 次（因为每一个数都多一个 1）。同理：$2000 \sim 2999$ 中的每个数字都出现 $f_3$ 次且数字 2 多出现了 $10^3$ 次。以此类推。

&emsp; 但是这还没完，首位 A 出现的次数没有被统计下来，因为在后面还会有 $\overline{A001}，\overline{A002}，\overline{A003}，\cdots，\overline{ABCD}$，也就是说最高位 A 还要再多出现 $\overline{BCD} + 1$ 次。

&emsp; 把这些因素都考虑进去之后，我们就把首位给处理完了。接着就是用同样的方法来处理抛开最高位之后剩下的最高位了。

&emsp; 当然，我们前面说的都是在一个大前提之下：不考虑前导0。所以现在我们需要把数字 0 出现的次数减去那些前导0 的个数。还是可以利用 "打表大法" 和 "瞪眼观察大法"，我们可以推出前导0的个数等于：$10^{i-1} + 10^{i-2} + \cdots + 10$。然后整道题就愉快地 A 掉了。

## 实现

&emsp; 综上所述，我们梳理一下求解的流程。
1. 预处理（或打表）出来一个 f 数组，其中 $f_i$ 表示在所有的 i 位数（包含前导0）中各个数码出现的次数。数值上 $f_i = i \times 10^{i-1}$。
2. 循环枚举各个数位，对每个数位进行以下操作（设这个数位是第 i 位上的数码为 A）：每个数码出现的次数加上 $A \times f_{i-1}$，然后比 A 小的数码出现次数再加上 $10^3$，然后 A 出现的次数再加上 $\overline{BCD} + 1$ 次。
3. 数字 0 出现的次数减去 $\sum_{n=1}^{i-1}10^n$ 次。

&emsp; 代码如下：

```c
#include<bits/stdc++.h>
using namespace std;
#define int long long

int l = 0; int r = 0;
int cntl[20] = { 0 }; int cntr[20] = { 0 };
int f[20] = { 0, 1, 20, 300, 4000, 50000, 600000, 7000000, 80000000, 900000000, 10000000000, 110000000000, 1200000000000, 13000000000000, 140000000000000, 1500000000000000 };

// 10 的 n 次方 
int power[20] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1000000000000000 };

void solve(int x, int cnt[]){
	int num[20] = { 0 }; int len = 0;
	while(x){
		num[++len] = x % 10; x /= 10;
	}
	for(int i = len; i >= 1; i--){
		for(int j = 0; j <= 9; j++){
			cnt[j] += num[i] * f[i-1];
		}
		for(int j = 0; j < num[i]; j++){
			cnt[j] += power[i-1];
		}
		int temp = 0;
		for(int j = i - 1; j >= 1; j--){
			temp = temp * 10 + num[j];
		}
		cnt[num[i]] += temp + 1;
		cnt[0] -= power[i-1];
	}
}

signed main(){
	scanf("%lld%lld", &l, &r);
	solve(l-1, cntl); solve(r, cntr);
	for(int i = 0; i <= 9; i++){
		printf("%lld ", cntr[i] - cntl[i]);
	}
	puts("");
	return 0;
}
```

 
