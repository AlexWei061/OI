# Data Structure

## segment tree

### [luogu1438 无聊的数列](https://www.luogu.com.cn/problem/P1438)

&emsp; (2022.4.1)

&emsp; 就是区间加等差数列和单点询问。

&emsp; 直接线段树维护差分数组，每次对于一个修改 $[l, r]$，在 $l$ 处加上 $s$（等差数列首相），在 $[l + 1, r]$ 处加上 $d$ （等差数列公差），在 $r + 1$ 处减去 $e$（等差数列末项）。然后每一次询问 $p$求出 $\sum\limits_{i = 1}^pc[i]$ 就好了。

## BIT

### [luogu8251 丹钓战](https://www.luogu.com.cn/problem/P8253)
&emsp; (2022.3.26) / ~~这个题也可以用主席树过掉qwq~~

&emsp; 很多二元组 $(a_i, b_i)$，按照 $a_i$ 不同和 $b_i$ 递增来维护单调栈，然后每次询问给定一个区间 $[l, r]$ 询问在这个区间里维护单调栈的时候栈中只有一个元素的时刻的个数。

&emsp; 预处理出每个位置 $i$ 入栈前弹栈后的栈顶，记为 $p[i]$。然后问题就能转化为 $[l, r]$ 区间中有多少 $p[i]$ 小于 $l$。因为如果 $p[i]$ 小于 $l$ 就说明在扫到 $i$ 的时候就已经把 $l$ 之后的二元组全部弹出栈了（要不然也不会是栈顶了嘛）。然后就可以把所有询问离线下来然后对于左端点排序，处理出扫到一个左端点的时候左端点的值。然后再关于右端点排序，处理出扫到右端点的时候小于左端点的值，处理可以用树状数组做。

-----

# Gragh Theory

## tree

### [WOJ10028 贸易](http://192.168.110.25/p/P10028)

&emsp; (2022.4.3)

&emsp; 就是给定一个无向图，然后让你保证每个边都有且仅有 $1$ 的入度。也就是转化成最小生成基环树森林。显然我们只需要把 $kruskal$ 稍微改造一下，也就是换一下判断是否加边的条件就能过掉这个题了：

&emsp; 我们考虑怎样加边来维护基环树森林。判断一条边能否加入的时候，如果这两个端点已经连通了，我们就需要知道这个连通块是否有环，如果没有环就连在一起，并标记他现在有环。如果不连通，那么还是判断两个有没有环。如果都有环就不加边，否则就加边并且标记两边是否有环。

## bipartite graph

### 一些前置芝士

&emsp; 在二分图 $G =(V, E)$ 中，规定边集 $M \in E$ 表示最大匹配，边集 $F \in E$ 表示最小边覆盖， 点集 $S_1 \in V$ 表示最大独立集，$S_2 \in V$ 表示最小顶点覆盖。

1. 边覆盖表示任意定边至少是 $F$ 中某条边的端点的边集。
2. 独立集表示两两互不相连的定点集合 $S_1$
3. 顶点覆盖表示任何一条边都至少有一个端点在 $S_2$ 中。

&emsp; 然后我们就有：

$$
\begin{aligned}
|M| +|F| & = |V| \\
|S_1| +|S_2| & = |V| \\
|M| & = |S_2|
\end{aligned}
$$

&emsp; 注意前两个式子在任意图中都成立，第三个式子只在二分图中成立。所以在二分图中，我们还能得到：

$$ |M| + |S_1| = |V| $$

### [luogu3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

&emsp; (2022.4.2)

&emsp; 板子题，直接 $bfs$ 找增广路然后每次取反直到找不到为止就是最大匹配了（匈牙利）。


### [luogu4304 攻击装置](https://www.luogu.com.cn/problem/P4304)

&emsp; (2022.4.2)

&emsp; 给一个 $n \times n$ 的中国象棋棋盘，然后给定一些地方可以放置一个 $马$，然后求能在棋盘上放置的最多的马的数量，并保证这些马不会相互共计（马走 "日" 大家应该都知道吧 qwq）。

&emsp; 考虑构图，如果两个点之间马可以相互到达就连一条边，那么就是要求这个无向图的最大独立集 $S_1$。但是一般图的最大独立集是一个 $NPC$ 问题，所以我们考虑证明我们构造出来的图是一个二分图。

&emsp; 如果我们对这个棋盘进行染色，像这样：

![在这里插入图片描述](/Alex/OI/pic/PR.png)

&emsp; 我们就能发现能连边的肯定都是不同颜色的两个点，所以是一个二分图，就能二分图最大匹配了。然后我们在二分图中又有：

$$ |S_1| = |V| - |M| $$

&emsp; 然后就做完了。

## web flow

## tarjan

------

# Dynamic Programming

## knapsack

### [luogu1734 最大约数和](https://www.luogu.com.cn/problem/P1734)

&emsp; (2022.4.3)

&emsp; 给一个正整数 $S \leq 1000$，要求选出若干个互不相同的正整数，是他们的和不大于 $S$，而且每个数的因数（不包含自身）之和最大。

&emsp; 显然（虽然考试的时候想了很久 qwq）是一个 $0/1$ 背包。物品就是要选出的正整数，容量是 $S$，然后每个的物品的因数之和。显然因数之和可以暴力 $O(S\sqrt{S})$ 预处理出来。所以总的复杂度就是 $O(S^2 + S\sqrt{S})$。

## digital dp

### [luogu P2602 数字计数](https://www.luogu.com.cn/problem/P2602)

&emsp; (2021.10.27)

&emsp; 给定两个正整数 a 和 b，求在 [a,b] 中的所有整数中，每个数码(digit)各出现了多少次。输出包含一行十个整数，分别表示 0∼9 在 [a,b] 中出现了多少次。

&emsp; 乍一看好像是一道大水题，再一看数据范围，$10^{12}$ .....，好吧这题不水。

&emsp; 但是这道题还是很良心的啊，都把 digit 数码在题目中给你写出来了，这不明摆着就是一道数位 DP 的题吗。那我们就来看看能不能把递推式给整出来。 

&emsp; 总思路：我们把从 a 到 b 的所有数字中的各个数码出现的次数转化成这样：1 ~ b 中的所有数字的各个数码出现的次数减去 1 ~ a - 1 中的所有数字的各个数码出现的次数。所以我们现在考虑怎样求出 1 ~ n 的所有数字的各个数码的出现次数。

&emsp; 首先，我们发现这一道题有一个很烦人的东西，叫做 "前导0"，因为有这个东西，所以我们很难直接写出递推式，只能在考虑了没有它的情况之后再减去考虑它之后的那些多出来的值。给没学过数位 DP 的读者们解释一下，"前导0" 是指我们在枚举数位的时候会碰到枚举出来的数是这样的情况：$\overline{0000abc...}$，这些真正的数字前面的 "0" 们我们就叫它们 "前导0"。

&emsp; 首先考虑没有前导 0 的情况，根据我们的 ~~数学常识~~ 我们可以知道，在 0 ~ 9，0 ~ 99，0 ~ 999 ... 这些区间里面，所有数字的出现次数是相同的。不知道这个 ~~c常识~~ 的读者可以试着自己打打表验证一下。如果我们把这些数字出现的次数算出来的话，我们会发现下面这样的规律：

$$
\begin{aligned}
0 \sim 9 &: 1\\
0 \sim 99 &: 20\\
0 \sim 999 &: 300\\
0 \sim 9999 &: 4000\\
0 \sim 99999 &: 50000\\
\vdots
\end{aligned}
$$

&emsp; 这个规律应该是很明显的了，如果我们把所有的 $i$ 位数（含前导0）中隔个数字出现的总次数记为 $f_i$ 那么我们就有 $f_i = 10 \times f_{i-1} + 10^{i-1}$。

&emsp; 既然我们有了这个规律，很自然的我们根据分治的思想可以想到把数字 a 分成不同的部分，我们考虑这样分（假设 $a = \overline{ABCD}$）：从最高位开始分别处理不同的位数，也就是分别处理：$\overline{A000}$，$\overline{0B00}$， $\overline{00C0}$ 和 $\overline{000D}$。

&emsp; 首先我们来讨论如何处理最高位： $\overline{A000}$。因为我们知道 0 ~ 999 之间的每个数字都出现了 $f_3$ 次，所以我们考虑先把这个 $\overline{A000}$ 看成 $\overline{0000} \sim \overline{1000} \sim \overline{2000} \sim \cdots \sim \overline{A000}$。感性的来讲，是不是所有数字都出现了 $A \times f_3$ 次呢？不是的，因为除了这些数字，还要加上首位出现的次数，也就是比 A 小的每个数要多出现 $10^3$ 次。

&emsp; 这应该比较好理解，如果不理解的话我简单的说一下，我们知道 $0 \sim 999$ 中的所有数字的各个数码出现次数相等且都是 $f_3$ 次。那我们是不是可以把这些书写成这样 $\overline{0000}， \overline{0001}，\overline{0002}， \cdots，\overline{0999}$，再看从 $1000 \sim 1999$ 的这些数字，如果忽略最高位 1，那么是不是他们就和 $0 \sim 999$ 一模一样，所以从 $1000 \sim 1999$ 中，所有数字都要出现 $f_3$ 次，且首位 1 会多出现 $10^3$ 次（因为每一个数都多一个 1）。同理：$2000 \sim 2999$ 中的每个数字都出现 $f_3$ 次且数字 2 多出现了 $10^3$ 次。以此类推。

&emsp; 但是这还没完，首位 A 出现的次数没有被统计下来，因为在后面还会有 $\overline{A001}，\overline{A002}，\overline{A003}，\cdots，\overline{ABCD}$，也就是说最高位 A 还要再多出现 $\overline{BCD} + 1$ 次。

&emsp; 把这些因素都考虑进去之后，我们就把首位给处理完了。接着就是用同样的方法来处理抛开最高位之后剩下的最高位了。

&emsp; 当然，我们前面说的都是在一个大前提之下：不考虑前导0。所以现在我们需要把数字 0 出现的次数减去那些前导0 的个数。还是可以利用 "打表大法" 和 "瞪眼观察大法"，我们可以推出前导0的个数等于：$10^{i-1} + 10^{i-2} + \cdots + 10$。然后整道题就愉快地 A 掉了。

&emsp; 综上所述，我们梳理一下求解的流程。
1. 预处理（或打表）出来一个 f 数组，其中 $f_i$ 表示在所有的 i 位数（包含前导0）中各个数码出现的次数。数值上 $f_i = i \times 10^{i-1}$。
2. 循环枚举各个数位，对每个数位进行以下操作（设这个数位是第 i 位上的数码为 A）：每个数码出现的次数加上 $A \times f_{i-1}$，然后比 A 小的数码出现次数再加上 $10^3$，然后 A 出现的次数再加上 $\overline{BCD} + 1$ 次。
3. 数字 0 出现的次数减去 $\sum\limits_{n=1}^{i-1}10^n$ 次。

-----

# Math

## 一些前置芝士

&emsp; 欧拉定理：
$$ \forall gcd(a, n) = 1 \rightarrow a^{\varphi(n)} \equiv 1 \pmod n $$

&emsp; 欧拉定理的推论：

$$ \forall gcd(a, n) = 1 \rightarrow a^{b \mod \varphi(n)} \equiv 1 \pmod n $$

&emsp; 费马小定理：

$$ \forall p 是质数 \rightarrow a^{p - 1} \equiv \pmod p $$

&emsp; exgcd()：

```cpp
int exgcd(int a, int b, int &x, int &y){
	if(b == 0) { x = 1; y = 0; return a; }
	int d = exgcd(b, a % b, x, y);
	int z = x; x = y; y = z - y * (a / b);
	return d;
}
```

&emsp; 中国剩余定理：

$$
(i:1 \to n) \;\;\;
\begin{cases}
x \equiv a_i \pmod {m_i} \\
m = \prod\limits_{i = 1}^nm_i \\
M_i = \frac{m}{m_i} \\
M_it_i \equiv 1 \pmod {m_i} 
\end{cases}
\rightarrow x = \sum_{i=1}^na_iM_it_i 
$$

&emsp; $Lucas$ 定理（把 $n$ 和 $m$ 表示成 $p$ 进制数，然后每一位计算组合数再乘起来）：

$$ p 是质数 \rightarrow C_n^m \equiv C_{n\mod p}^{m\mod p} \times C_{\frac np}^{\frac mp} \pmod p $$

## [luogu2480 古代猪文](https://www.luogu.com.cn/problem/P2480)

&emsp; (2022.4.3)

&emsp; 给你 $q, n \in [1, 10^9]$，算 $q^{\sum\limits_{d | n}C_n^d} \mod p$, 其中 $p = 999911659$。

&emsp; 如果 $q = p$，那么上式结果为 $0$。否则，因为 $p$ 是质数，所以 $gcd(q, n)$ 互质。所以根据欧拉定理的推论，我们就能得到：

$$ q^{\sum\limits_{d | n}C_n^d} \equiv q^{\sum\limits_{d | n}C_n^d \mod (p-1)} \pmod p $$

&emsp; 所以我们只需要知道怎么计算 $\sum\limits_{d|n}C_n^d \mod (p-1)$ 就可以了。经过观察我们发现 $p - 1 = 2 \times 3 \times 4679 \times 35617$，所以它是一个 $square-free-number$（就是所有质因子的指数都是 $1$ 的数 qwq）。所以在这里我们可以枚举 $n$ 的因数 $d$ 然后用 $Lucas$ 定理来计算 $C_n^d \mod (p-1)$，然后分别计算出 $\sum\limits_{d|n}C_n^d$ 对 $2, 3, 4679, 35617$ 四个质数取模的结果。我们把他们记为 $a_1, a_2, a_3, a_4$。

&emsp; 然后我们解出下面这个方程组的根 $x$ 就是 $\sum\limits_{d|n}C_n^d \mod (p-1)$ 的最小非负整数解。

$$
\begin{cases}
x \equiv 2 \pmod {a_1} \\
x \equiv 3 \pmod {a_2} \\
x \equiv 4679 \pmod {a_3} \\
x \equiv 35617 \pmod {a_4}
\end{cases}
$$

&emsp; 解这个方程很显然就是中国剩余定理。然后我们就用快速幂求 $q^x$ 就是答案了。

------

# Construct

## [luogu8252 讨论](https://www.luogu.com.cn/problem/P8252)

&emsp; (2022.3.31)

### 构造

&emsp; 大概就是给 $n$ 个集合，每个集合 $k_i$ 个元素，然后判断这些集合中有没有满足有交且不包含的。如果有输出 $YES$ 和这两个集合的编号，如果没有就输出 $NO$。

&emsp; 我们维护一个 $last[i]$ 数组表示当前枚举到的人中会做 $i$ 题的最后一个人的编号（其实就是染色（后面会说） qwq）。然后我们通过一些分析就能得出一些神奇的性质。

&emsp; 首先，如果我们在枚举第 $now$ 个人会做的题目 $p$ 时，发现 $last_p = 0$。那么说明 $now$ 就是枚举到的人中第一个会做 $p$ 这道题的人。如果是这样就比较好处理，我们只需要找到一个在前面找一个与 $i$ 有交的人就好了（因为有题目 $p$ 的存在所以前面的人不可能包含 $now$）。

&emsp; 那么第二种情况 $last_p$ 有值，现在的问题就是要求 $last_p$ 和 $now$ 不能是包含关系。我们为了方便，记 $x = last_p$。然后我们继续枚举其他题，发现有另一道题的 $last_{p'} \neq x$。那我们把现在的 $last_{p'}$ 也记录下来记为 $y$。现在我们就有了两个不同的人，他们**都满足与 $now$ 有题目交集。** 

&emsp; 现在我们找到 $x$ 和 $y$ 中 $k$ 较小的那个（假设 $k[x] > k[y]$）。因为排序，所以 $y$ 的枚举的顺序肯定在 $x$ 之后，又因为 $last_{p} = x \neq y$，所以 $y$ 肯定不会做题 $p$，又因为 $now$ 会做 $p$，**所以 $now$ 和 $y$ 肯定不是包含关系**，那么久满足了这道题的要求。那我们就输出 $now$ 和 $y$ 就搞定了。

### 染色

&emsp; 前面的构造没看懂没关系，我们来看看更容易理解的一种算法（其实和构造是差不多等效的），看完染色再回去看构造应该就能有更深的理解 qwq。首先对所有人按照所对应的集合的 $size$ 从大到小排序，然后从头到尾扫一遍，然后执行以下操作：

1. 对于每一个人的集合中的题将他们染成同一个颜色。
2. 如果当前这个人的题目集合跨越了两个颜色，那么我们就找到了要讨论的人。

&emsp; 我们对所有人进行排序是为了保证之后扫到的人不可能包含前面扫到的人的集合。按照这个算法进行在找到能讨论的两个人之前染色的情况应该是只有包含和不交两种情况，像这样：

![在这里插入图片描述](/Alex/OI/pic/NOIonline221.png)

&emsp; 然后我们找到了一个能讨论的集合包含了两种颜色，就像这样：

![在这里插入图片描述](/Alex/OI/pic/NOIonline222.png)

&emsp; 就直接找然后输出就做完了。

---------

# Search

## A*

&emsp; (2021.10.15)

### [luogu1379 八数码难题](https://www.luogu.com.cn/problem/P1379)

#### 判断可行

&emsp; $3 \times 3$ 的九宫格，其中 $8$ 个格子中有 $1 \sim 8$ 的 $8$ 个数字。很显然这 $8$ 个数字有很多种填写方法。我们有一个操作，就是九宫格中没有填数字的方格和旁边的数字交换。现在我们给出两个状态，然后我们要判断两种状态是否能通过若干个操作互相到达，如果能互相到达就输出操作次数最少的一种方法的操作步数。

&emsp; 首先判断能否相互到达，八数码游戏的两个局面可达，当且仅当把两个局面写成一维形式的时候，逆序对个数的奇偶性相同。证明很简单，分为两种情况。第一种情况：我们左右移动空格位置的时候，一维形式数列不变，所以逆序对奇偶性不变。第二种情况：我们上下移动空格位置的时候，在一维形式上的表现就是某个数与它前（后）面的 2 个数进行位置互换。此时我们又要分两种情况讨论。
1. 与它进行位置交换的两个数都比它大（小）那么逆序对数量就减少（增加）2。逆序对数量奇偶性不变。
2. 与他进行交换的两个数一个比他大，另一个比他小，那么逆序对的数量加一再减一就没有变化，所以逆序对数量奇偶性不变。

&emsp; 然后我们就可以对于两次给出的局面维护一个树状数组求出两次的逆序对数量（也可以用归并排序求逆序对）然后判断奇偶性是否相同就好了。

#### 步数最小

&emsp; 然后，首先利用上述方法判断是否可解，若问题有解，那我们就采用 A* 算法搜索出一种移动部步数最小的方案。我们令评估函数为当前位置和目标位置有几个数的位置不相同，即：
$$ f(state) = \sum_{i=1}^{9} (state_{xi} ==  goal_{xi} \; and \; state_{yi} == goal_{yi}) \; ? \; 0 \; : \; 1 $$
&emsp; 然后每次我们用当前步数 g(state) 加上 f(state) 来进行扩展，最终状态第一次被从堆中取出时就是最优解。

---------

# Other

## 单调队列

### [WOJ4744 最佳序列](http://192.168.110.251/problempage.php?problem_id=4744)

&emsp; (2022.4.3)

&emsp; 给定一个长度为 $n$ 的数组  $a$。给定 $L, R$，求所有满足长度大于等于 $L$ 小于等于 $R$ 的 $a$ 的子区间的平均值的最大。

&emsp; 先二分答案，也就是二分平均值，然后每个数减去这个平均值，这个时候所有和大于 $0$ 的区间的平均值就肯定大于二分的值。

&emsp; 统计减去平均值的后序列的前缀和，问题就变成了前缀和在 $[i - R, i - L]$ 区间内是否存在一个数 $s_j$ 使得 $s_i > s_j$，然后就是单调队列优化就能做到 $O(n)$。