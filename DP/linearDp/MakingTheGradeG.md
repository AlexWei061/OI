# Making The Grade G
&emsp; 原题传送门： [luogu P2893 USACO08FEB](https://www.luogu.com.cn/problem/P2893)

&emsp; 题目大意： 给定一个长度为 $N$ 的序列 $A$ 让你构造一个长度也为 $N$ 的序列 $B$，且 $B$ 非严格单调(不限制单增或单减)，且要最小化 $T = \sum\limits_{i=1}^N \mid A_i - B_i \mid$。

&emsp; 因为这里分成两种情况，一种 $B$ 是非严格单增的，另一种 $B$ 是非严格单减的，所以我们考虑分别对这两种情况进行求解，最后再去一个最小值就好了。下面我们就以 $B$ 是非严格单增来举例子（非严格单减同理）。

&emsp; 在分析的过程中，我们发现一个神奇的现象，在满足最小化 $T$ 的前提下，一定存在一种构造 $B$ 的方案，使得 $B$ 中的所有数值都在 $A$ 中出现过。首先，当 $N = 1$ 的时候这个命题显然成立（最小化 $T$ 之间让 $B_1 = A_1$ 就好了）。之后我们考虑先假设这个命题对 $N = k-1$ 成立，如果能推出这个命对 $N = k$ 成立，在运用数学归纳法，就能证明这个命题对所有 $N$ 都成立了。

&emsp; 现在设命题对 $N = k-1$ 时成立，且此时构造出来的序列是 $B_1 \sim B_{k-1}$。然后我们来分类讨论 $B_{k-1}$ 和 $A_k$ 的大小情况：

1. 如果 $B_{k-1} \leq A_k$，则令 $B_k = A_k$ 则我们就把 $k$ 这里消成了 0，而且还满足单增。并且前面已经构造出最小的了，所以现在肯定也是最小的，此时命题成立。
2. 当 $B_{k-1} > A_k$ 的时候还要分成两种情况，第一种情况是直接令 $B_k = B_{k-1}$ 命题成立。
&emsp; 第二种当这样直接构造不成立的时候就要考虑其他的构造方式了。因为直接令 $B_{k} = B_{k-1}$ 不行了，所以我们考虑下调 $B$ 数列前面的数，因为要向下调整，所以我们前面构造好的数也要向下一起调整。
&emsp; 所以我们发现，我们一定能够找到一个 $j$ 然后重新令 $B_{j}, B_{j+1}, \cdots B_{k}$ 都等于一个新的值 $x$，使得原命题成立。但是为什么要统一下调到 $x$ 呢，难道不存在一种可能使得前面的数下调到比 $x$ 还小使得整个数列的 $T$ 更优吗？显然是不存在的，因为如果可以让前面的更小来满足更优那么这个数就不会在 $[j, k]$ 这一段里，它会在之前构造 $k-1$ 的长度的时候就被调成更小的而满足最优。
&emsp; 这个时候问题就变成了找到一个数 $x$ 证明当 $T' = \sum\limits_{i=j}^k \mid x - A_i \mid$ 时 $x$ 一定在 $A$ 里面出现过。而对于这个式子： $T' = \sum\limits_{i=j}^k \mid x - A_i \mid$，其实就是一个中位数问题。设 $mid$ 是 $A[j\sim k]$ 的中位数，如果 $mid \geq B_{j-1}$，让 $x = mid$ 就能最小化 $T'$。当 $mid < B_{j-1}$ 的时候我们就让 $x = B_{j-1}$ 就能保证最优且单调。而且 $mid$ 和 $B_{j-1}$ 都是 $A$ 中的数值。所以原命题成立。

&emsp; 我们上面已经证明了这个神奇的命题，那下面转移方程就比较容易了。我们设 $F[i]$ 表示对于 $A[1\sim i]$ 完成构造，且 $A[i] = B[i]$ 的时候，$T$ 的最小值。我们仿照 LIS 就能得到下面的动态转移方程：
$$ F[i] = \min_{0 \leq j < i， A[j] \leq A[i]}\lbrace F[j] + c(j+1, i-1) \rbrace $$

&emsp; 其中，我们设 $c(j+1, i-1)$ 表示构造 $B_{j+1}, B_{j+1}, \cdots B_{i-1}$ 的最小代价。也就是构造出 $B_{j+1}, B_{j+1}, \cdots B_{i-1}$，且满足 $A_j \leq B_{j+1} \leq B_{j+1} \leq \cdots \leq B_{i-1} \leq A_i$ 的时候 $\sum\limits_{k=j+1}^{i-1}\mid A_k - B_k \mid$ 的最小值。

&emsp; 现在我们就要想办法求解出 $c(j+1, i-1)$ 等于多少了。根据我们上面的神奇的命题，$B$ 数列一定是由一段一段的 $A$ 数列里面的值组成的，又因为 $i$ 处刚好 $A[i] = B[i]$ 且 $j$ 处也满足 $A[j] = B[j]$，所以我们要构造的中间的一坨东西就是前面一部分是 $A[j]$，后面一部分是 $A[i]$ 的一个序列，然后我们就用一个 $k$ 来枚举分界点就好了。这样的算法的时间复杂度就是 $O(n^3)$，显然过不了。 

&emsp; 然后我们考虑优化一下，一个状态的转移不行，我们就多加一个状态，我们直接把上一次构造的 $B$ 序列的最后一个值也加在状态里面，也就是记 $F[i, j]$ 表示完成对 $A[1\sim i]$ 的构造，且构造出来的 $B$ 中 $B[i] = j$ 时 $T$ 的最小值。那么我们就有：
$$ F[i, j] = \min_{0 \leq k < j} \lbrace F[i-1, k] + \mid A[i] - j \mid \rbrace $$

&emsp; 然后我们可以对 $A$ 进行离散化，把状态的第二维降到 $O(n)$。然而状态转移还是 $O(n)$ 的，所以整个的复杂度也还是 $O(n^3)$ 的。但是我们可以继续优化，我们记 $S(j)$ 表示满足转移条件 $0 \leq k < j$ 的所有 $k$ 的集合。我们发现，在每一次枚举 $j$ 的时候这个决策集合只增不减，所以在找 $k$ 的时候我们就不用每次都枚举 $k$，直接用 $j$ 来代表 $k$ 就可以了，这样我们就可以做到 $O(1)$ 的转移。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 2020
#define endl '\n'

int a[MAXN] = { 0 };
int b[MAXN] = { 0 };
int n = 0; int m = 0;

int ans = 0;
int f[MAXN][MAXN] = { 0 };
void dp(){
	for(int i = 1; i <= n; i++){
		int minx = f[i-1][1];
		for(int j = 1; j <= n; j++){
			minx = min(minx, f[i-1][j]);
			f[i][j] = minx + abs(b[j] - a[i]);
		}
	}
}

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]), b[i] = a[i];
	sort(b+1, b+n+1); m = unique(b+1, b+n+1) - b - 1;
	dp(); ans = f[n][1];
	for(int i = 2; i <= m; i++) ans = min(ans, f[n][i]);
	reverse(a+1, a+n+1); dp();
	for(int i = 1; i <= m; i++) ans = min(ans, f[n][i]);
	cout << ans << endl;
	return 0;
}
```